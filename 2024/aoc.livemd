# Advent of code 2024

## Day 1

```elixir
defmodule Day_1 do
  def input do
    """
    3   4
    4   3
    2   5
    1   3
    3   9
    3   3
    """

    File.read!("/home/andy/adventofcode/2024/day1.txt")
  end

  def get_lists() do
    Day_1.input()
    |> String.split()
    |> Enum.map(&String.to_integer(&1))
    |> Enum.chunk_every(2)
    |> Enum.reduce({[], []}, fn [i, j], {acc_i, acc_j} ->
      {[i | acc_i], [j | acc_j]}
    end)
  end

  def run_part1() do
    {l1, l2} = get_lists()

    l1 = Enum.sort(l1)
    l2 = Enum.sort(l2)

    Enum.zip(l2, l1)
    |> Enum.map(fn
      {i, j} when i > j -> i - j
      {i, j} -> j - i
    end)
    |> Enum.sum()
  end

  def run_part2() do
    {l1, l2} = get_lists()
    fq = Enum.frequencies(l2)

    Enum.map(l1, fn l -> l * Map.get(fq, l, 0) end)
    |> Enum.sum()
  end
end
```

```elixir
Day_1.run_part1()
```

```elixir
Day_1.run_part2()
```

## Day 2

```elixir
defmodule Day_2 do
  def input() do
    """
    7 6 4 2 1
    1 2 7 8 9
    9 7 6 2 1
    1 3 2 4 5
    8 6 4 4 1
    1 3 6 7 9
    """

    File.read!("/home/andy/adventofcode/2024/day2.txt")
  end

  def calculate(list, opts \\ []) do
    cond do
      Enum.sort(list, :asc) == list ->
        :increase

      Enum.sort(list, :desc) == list ->
        :decrease

      true ->
        :unknown
    end
    |> is_safe?(list, opts)
  end

  def get_level_differ(list, head) do
    Enum.reduce(list, {[], head}, fn l, {i, j} ->
      r = l - j
      {i ++ [r], l}
    end)
    |> elem(0)
  end

  def is_safe?(_, _, opts \\ [])

  def is_safe?(:increase, [head | list], opts) do
    result =
      get_level_differ(list, head)
      |> Enum.all?(fn i -> i in [1, 2, 3] end)

    if Keyword.get(opts, :recheck, true) do
      result
      |> is_is_safe?([head | list])
    else
      result
    end
  end

  def is_safe?(:decrease, [head | list], opts) do
    result =
      get_level_differ(list, head)
      |> Enum.all?(fn i -> i in [-1, -2, -3] end)

    if Keyword.get(opts, :recheck, true) do
      result
      |> is_is_safe?([head | list])
    else
      result
    end
  end

  def is_safe?(_, list, opts) do
    if Keyword.get(opts, :recheck, true) do
      false
      |> is_is_safe?(list)
    else
      false
    end
  end

  def is_is_safe?(true, _) do
    true
  end

  def is_is_safe?(false, list) do
    list
    |> Enum.with_index()
    |> Enum.map(fn {_, index} ->
      List.delete_at(list, index)
    end)
    |> Enum.map(fn l ->
      calculate(l, recheck: false)
    end)
    |> Enum.any?()
  end

  def run_part1() do
    Day_2.input()
    |> String.split("\n", trim: true)
    |> Enum.map(fn l ->
      String.split(l)
      |> Enum.map(&String.to_integer(&1))
      |> Day_2.calculate(recheck: false)
    end)
    |> Enum.count(fn r -> r == true end)
  end

  def run_part2() do
    Day_2.input()
    |> String.split("\n", trim: true)
    |> Enum.map(fn l ->
      String.split(l)
      |> Enum.map(&String.to_integer(&1))
      |> Day_2.calculate()
    end)
    |> Enum.count(fn r -> r == true end)
  end
end
```

```elixir
Day_2.run_part1()
```

```elixir
Day_2.run_part2()
```

## Day 3

```elixir
defmodule Day_3 do
  def input do
    "xmul(2,4)%&mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))"
    File.read!("/home/andy/adventofcode/2024/day3.txt")
  end

  def input2 do
    "xmul(2,4)&mul[3,7]!^don't()_mul(5,5)+mul(32,64](mul(11,8)undo()?mul(8,5))"
  end

  def calculate(x) do
    Regex.named_captures(~r/mul\((?<f1>\d+),(?<f2>\d+)\)/, x)
    |> Map.values()
    |> Enum.map(&String.to_integer(&1))
    |> Enum.product()
  end

  def run_part1() do
    Regex.scan(~r/mul\(\d+,\d+\)/, Day_3.input())
    |> Enum.map(fn [x] -> calculate(x) end)
    |> Enum.sum()
  end

  def run_part2() do
    Regex.scan(~r/mul\(\d+,\d+\)|do\(\)|don't\(\)/, Day_3.input())
    |> Enum.map(fn [x] -> x end)
    |> Enum.reduce({[], "do()"}, fn i, {acc, x} ->
      cond do
        i == "do()" -> {acc, i}
        i == "don't()" -> {acc, i}
        x == "do()" -> {acc ++ [i], x}
        true -> {acc, x}
      end
    end)
    |> elem(0)
    |> Enum.map(fn x -> calculate(x) end)
    |> Enum.sum()
  end
end
```

```elixir
Day_3.run_part1()
```

```elixir
Day_3.run_part2()
```
