# Advent of code 2024

## Day 1

```elixir
defmodule Day_1 do
  def input do
    """
    3   4
    4   3
    2   5
    1   3
    3   9
    3   3
    """

    File.read!("/home/andy/adventofcode/2024/day1.txt")
  end

  def get_lists() do
    Day_1.input()
    |> String.split()
    |> Enum.map(&String.to_integer(&1))
    |> Enum.chunk_every(2)
    |> Enum.reduce({[], []}, fn [i, j], {acc_i, acc_j} ->
      {[i | acc_i], [j | acc_j]}
    end)
  end

  def run_part1() do
    {l1, l2} = get_lists()

    l1 = Enum.sort(l1)
    l2 = Enum.sort(l2)

    Enum.zip(l2, l1)
    |> Enum.map(fn
      {i, j} when i > j -> i - j
      {i, j} -> j - i
    end)
    |> Enum.sum()
  end

  def run_part2() do
    {l1, l2} = get_lists()
    fq = Enum.frequencies(l2)

    Enum.map(l1, fn l -> l * Map.get(fq, l, 0) end)
    |> Enum.sum()
  end
end
```

```elixir
Day_1.run_part1()
```

```elixir
Day_1.run_part2()
```

## Day 2

```elixir
defmodule Day_2 do
  def input() do
    """
    7 6 4 2 1
    1 2 7 8 9
    9 7 6 2 1
    1 3 2 4 5
    8 6 4 4 1
    1 3 6 7 9
    """

    File.read!("/home/andy/adventofcode/2024/day2.txt")
  end

  def calculate(list, opts \\ []) do
    cond do
      Enum.sort(list, :asc) == list ->
        :increase

      Enum.sort(list, :desc) == list ->
        :decrease

      true ->
        :unknown
    end
    |> is_safe?(list, opts)
  end

  def get_level_differ(list, head) do
    Enum.reduce(list, {[], head}, fn l, {i, j} ->
      {i ++ [l - j], l}
    end)
    |> elem(0)
  end

  def is_safe?(_, _, opts \\ [])

  def is_safe?(:increase, [head | list], opts) do
    result =
      get_level_differ(list, head)
      |> Enum.all?(fn i -> i in [1, 2, 3] end)

    if Keyword.get(opts, :recheck, true) do
      result
      |> is_is_safe?([head | list])
    else
      result
    end
  end

  def is_safe?(:decrease, [head | list], opts) do
    result =
      get_level_differ(list, head)
      |> Enum.all?(fn i -> i in [-1, -2, -3] end)

    if Keyword.get(opts, :recheck, true) do
      result
      |> is_is_safe?([head | list])
    else
      result
    end
  end

  def is_safe?(_, list, opts) do
    if Keyword.get(opts, :recheck, true) do
      false
      |> is_is_safe?(list)
    else
      false
    end
  end

  def is_is_safe?(true, _) do
    true
  end

  def is_is_safe?(false, list) do
    list
    |> Enum.with_index()
    |> Enum.map(fn {_, index} ->
      List.delete_at(list, index)
      |> calculate(recheck: false)
    end)
    |> Enum.any?()
  end

  def run_part1() do
    Day_2.input()
    |> String.split("\n", trim: true)
    |> Enum.map(fn l ->
      String.split(l)
      |> Enum.map(&String.to_integer(&1))
      |> Day_2.calculate(recheck: false)
    end)
    |> Enum.count(fn r -> r == true end)
  end

  def run_part2() do
    Day_2.input()
    |> String.split("\n", trim: true)
    |> Enum.map(fn l ->
      String.split(l)
      |> Enum.map(&String.to_integer(&1))
      |> Day_2.calculate()
    end)
    |> Enum.count(fn r -> r == true end)
  end
end
```

```elixir
Day_2.run_part1()
```

```elixir
Day_2.run_part2()
```

## Day 3

```elixir
defmodule Day_3 do
  def input do
    "xmul(2,4)%&mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))"
    File.read!("/home/andy/adventofcode/2024/day3.txt")
  end

  def input2 do
    "xmul(2,4)&mul[3,7]!^don't()_mul(5,5)+mul(32,64](mul(11,8)undo()?mul(8,5))"
  end

  def calculate(x) do
    Regex.named_captures(~r/mul\((?<f1>\d+),(?<f2>\d+)\)/, x)
    |> Map.values()
    |> Enum.map(&String.to_integer(&1))
    |> Enum.product()
  end

  def run_part1() do
    Regex.scan(~r/mul\(\d+,\d+\)/, Day_3.input())
    |> Enum.map(fn [x] -> calculate(x) end)
    |> Enum.sum()
  end

  def run_part2() do
    Regex.scan(~r/mul\(\d+,\d+\)|do\(\)|don't\(\)/, Day_3.input())
    |> Enum.reduce({[], "do()"}, fn [i], {acc, x} ->
      cond do
        i == "do()" -> {acc, i}
        i == "don't()" -> {acc, i}
        x == "do()" -> {acc ++ [i], x}
        true -> {acc, x}
      end
    end)
    |> elem(0)
    |> Enum.map(fn x -> calculate(x) end)
    |> Enum.sum()
  end
end
```

```elixir
Day_3.run_part1()
```

```elixir
Day_3.run_part2()
```

## Day 4

```elixir
defmodule Day_4 do
  def input() do
    """
    MMMSXXMASM
    MSAMXMSMSA
    AMXSXMAAMM
    MSAMASMSMX
    XMASAMXAMM
    XXAMMXXAMA
    SMSMSASXSS
    SAXAMASAAA
    MAMMMXMMMM
    MXMXAXMASX
    """

    File.read!("day4.txt")
  end

  def get_word(str) do
    word = String.split(str, "", trim: true)
    word_reverse = Enum.reverse(word)
    {word, word_reverse, 0..(length(word) - 1)}
  end

  def get_grid() do
    Day_4.input()
    |> String.split("\n", trim: true)
    |> Enum.map(fn i -> String.split(i, "", trim: true) end)
  end

  def gen_diagonal(grid, i, j) do
    unless i < 0 || j < 0 do
      (Enum.at(grid, i) || [])
      |> Enum.at(j)
    end
  end

  @spec add_count(Integer.t(), boolean()) :: Integer.t()
  def add_count(count, res) do
    if res do
      count + 1
    else
      count
    end
  end

  def run_part1() do
    grid = Day_4.get_grid()

    {word, word_reverse, from_to} = Day_4.get_word("XMAS")

    Enum.with_index(grid)
    |> Enum.reduce(0, fn {y, i}, count ->
      Enum.with_index(y)
      |> Enum.reduce(count, fn {_x, j}, inner_count ->
        horizontal = Enum.map(from_to, fn g -> grid |> Enum.at(i) |> Enum.at(j + g) end)
        vertical = Enum.map(from_to, fn g -> (grid |> Enum.at(i + g) || []) |> Enum.at(j) end)
        diagonal_1 = Enum.map(from_to, &Day_4.gen_diagonal(grid, i + &1, j + &1))
        diagonal_2 = Enum.map(from_to, &Day_4.gen_diagonal(grid, i + &1, j - &1))

        inner_count
        |> Day_4.add_count(horizontal == word)
        |> Day_4.add_count(horizontal == word_reverse)
        |> Day_4.add_count(vertical == word)
        |> Day_4.add_count(vertical == word_reverse)
        |> Day_4.add_count(diagonal_1 == word)
        |> Day_4.add_count(diagonal_1 == word_reverse)
        |> Day_4.add_count(diagonal_2 == word)
        |> Day_4.add_count(diagonal_2 == word_reverse)
      end)
    end)
  end

  def run_part2() do
    grid = Day_4.get_grid()

    {word, word_reverse, from_to} = Day_4.get_word("MAS")

    Enum.with_index(grid)
    |> Enum.reduce(0, fn {y, i}, count ->
      Enum.with_index(y)
      |> Enum.reduce(count, fn {_x, j}, inner_count ->
        diagonal_1 = Enum.map(from_to, &Day_4.gen_diagonal(grid, i + &1, j + &1))
        diagonal_2 = Enum.map(from_to, &Day_4.gen_diagonal(grid, i + &1, j - &1 + 2))

        inner_count
        |> Day_4.add_count(diagonal_1 == word && diagonal_2 == word)
        |> Day_4.add_count(diagonal_1 == word && diagonal_2 == word_reverse)
        |> Day_4.add_count(diagonal_1 == word_reverse && diagonal_2 == word)
        |> Day_4.add_count(diagonal_1 == word_reverse && diagonal_2 == word_reverse)
      end)
    end)
  end
end
```

```elixir
Day_4.run_part1()
```

```elixir
Day_4.run_part2()
```
